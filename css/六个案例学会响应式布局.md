## 六个案例学会响应式布局

https://www.bilibili.com/video/BV1ov411k7sm

http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html

### 什么是媒体查询

概念：为不同尺寸的屏幕设定不同的css样式

示例：

```css
  <style>
    .box {
      width: 200px;
      height: 200px;
    }
    @media screen and (min-device-width: 100px) and (max-device-width: 300px) {
      .box {
        background-color: red;
      }
    }
    @media screen and (min-device-width: 300px) and (max-device-width: 500px) {
      .box {
        background-color: green;
      }
    }
  </style>
```

屏幕尺寸在100px - 300px 背景颜色为red，300px-500px 背景颜色为green



### @media常用参数

|   属性名称    |         作用         |
| :-----------: | :------------------: |
| width、height | 浏览器可视宽度、高度 |
| device-width  |    设备屏幕的宽度    |
| device-height |    设备屏幕的高度    |

```css
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .box {
      width: 100%;
      height: 200px;
    }
    .box div {
      float: left;
      height: 100px;
    }
    .box div:nth-child(1) {
      background-color: pink;
    }
    .box div:nth-child(2) {
      background-color: green;
    }
    .box div:nth-child(3) {
      background-color: yellow;
    }
    @media screen and (min-width: 100px) and (max-width: 200px) {
      .box div {
        width: 100%;
      }
    }
    @media screen and (min-width: 200px) and (max-width: 400px) {
      .box div {
        width: 50%;
      }
    }
    @media screen and (min-width: 400px) {
      .box div {
        width: 33.33%;
      }
    }
  </style>
```



### 媒体查询其他引入方式1

```html
  <style media="(min-width: 100px) and (max-width: 200px)">
    .box div {
      width: 100%;
    }
  </style>
  <style media="(min-width: 200px) and (max-width: 400px)">
    .box div {
      width: 50%;
    }
  </style>
  <style media="(min-width: 400px)">
    .box div {
      width: 33.33%;
    }
  </style>
```



### 媒体查询其他引入方式2

```html
  <link rel="stylesheet" href="./test.css">
  <link rel="stylesheet" href="./media1.css" media="(min-width: 100px) and (max-width: 200px)">
  <link rel="stylesheet" href="./media2.css" media="(min-width: 200px) and (max-width: 400px)">
  <link rel="stylesheet" href="./media3.css" media="(min-width: 400px)">
```



### 什么是flex

FlexiableBox即是弹性盒子，用来进行弹性布局，可以配合rem处理尺寸的适配问题

http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool

![500](https://gitee.com/itxing666/blog-images/raw/master/img/202201071018684.png)

|     属性值      | 作用 |
| :-------------: | :--: |
| flex-direction  |      |
|    flex-wrap    |      |
|    flex-flow    |      |
| justify-content |      |
|   align-items   |      |
|  align-content  |      |



### 主轴方向与换行

**flex-direction**: 子元素在父元素盒子中的排列方式

|     属性值     |              作用              |
| :------------: | :----------------------------: |
|      row       |  默认值，按从左到有的顺序显示  |
|  row-reverse   |  与row相同，但是以相反的顺序   |
|     column     |   垂直显示，按从上到下的顺序   |
| column-reverse | 与column相同，但是以相反的顺序 |

![503](https://gitee.com/itxing666/blog-images/raw/master/img/202201071654801.png)



**flex-wrap**：子元素在父元素盒子中是否换行

|    属性值    |                       作用                       |
| :----------: | :----------------------------------------------: |
|    nowrap    | （默认）不换行（会自行压缩，即使子元素设置宽度） |
|     wrap     |                    换行/换列                     |
| wrap-reverse |            换行/换列，但以相反的顺序             |



**flex-flow**：flex-direction和flex-wrap属性的简写方式,默认值 `row nowrap`

```css
 flex-flow: <flex-direction> || <flex-wrap>;
```



### 剩余空间调整为间距

**justify-content**：定义子元素在父元素主轴上的对齐方式

|     属性      |                             作用                             |
| :-----------: | :----------------------------------------------------------: |
|  flex-start   |                        (默认值)左对齐                        |
|   flex-end    |                            右对齐                            |
|    center     |                             居中                             |
| space-between |                两端对齐，项目之间的间隔都相等                |
| space-around  | 每个子元素两侧的间隔相等。所以，子元素之间的间隔比其与边框的间隔大一倍。 |
| space-evenly  |                      所有间隔匀称、平等                      |



### 交叉轴的对齐方式

**align-items**：定义子元素在交叉轴上如何对齐

|      属性       |                         作用                         |
| :-------------: | :--------------------------------------------------: |
|   flex-start    |                   交叉轴的起点对齐                   |
|    flex-end     |                   交叉轴的终点对齐                   |
|     center      |                   交叉轴的中点对齐                   |
|    baseline     |             子元素的第一行文字的基线对齐             |
| stretch(默认值) | 如果子元素未设置高度或设为auto，将占满这个容器的高度 |



**align-content**：定义了多行的整体对齐方式。如果子元素只有一行，该元素不起作用

|     属性     |  作用  |
| :----------: | :----: |
|  flex-start  |        |
|   flex-end   |        |
|    center    |        |
|   stretch    | 默认值 |
| flex-between |        |
| flex-around  |        |

![504](https://gitee.com/itxing666/blog-images/raw/master/img/202201072007117.png)

### 子元素的设置

|   属性值    |                             作用                             |
| :---------: | :----------------------------------------------------------: |
|    order    |       子元素的排列顺序。数值越小，排列越靠前，默认为0        |
|  flex-grow  | 子元素的放大比例，默认为0，即存在剩余空间，也不放大<br />不为0时，即使有width，也会按照比例 |
| flex-shrink | 子元素的缩小比例，默认为1，即如果空间不足，子元素将缩小<br />如果一个子元素为0，其他子元素为1，空间不足时，前者不缩小 |
| flex-basis  | 分配多余空间之前，子元素占据主轴的宽度<br />默认为auto，即子元素本身的宽度大小 |
|    flex     | flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto。<br />`auto` (`1 1 auto`)  none (`0 0 auto`)  `1` (`1 1 0%`) |
| align-self  | 单个子元素与其他元素对齐方式不一样<br />align-self: auto（默认值） \| flex-start \| flex-end \| center \| baseline \| stretch; } |



### flex简写

|             属性             |                 作用                 |
| :--------------------------: | :----------------------------------: |
|         flex: auto;          |           flex: 1 1 auto;            |
|         flex: none;          |           flex: 0 0 auto;            |
|           flex: 1;           |            flex: 1 1 0%;             |
| flex: 20%; \|\| flex: 200px; | flex: 1 1 20%; \|\| flex: 1 1 200px; |
|          flex: 2 3;          |            flex: 2 3 0%;             |
|        flex: 2 200px;        |           flex: 2 1 200px;           |



### rem

相对于根元素的字体大小的单位

使用媒体查询+rem或js,在不同宽度的视口下自动调整字体大小



### 自适应布局

1. 根据设备类型跳转至移动端／PC端页面

   ```
     const userAgent = navigator.userAgent.toLowerCase();
     const deviceReg = /(ipod|ipad|iphone|android|coolpad|mmp|smartphone|midp|wap|xoom|symbian|j2me|blackberry|wince)/
     window.location.href = deviceReg.test(userAgent) ? 'mobile.html' : 'pc.html'
   ```

2. 部分自适应，结合媒体查询



### 响应式布局





https://blog.csdn.net/sinat_17775997/article/details/89087348

一、静态布局
 页上的所有元素的尺寸一律使用px作为单位
 1.布局特点
 不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。
 常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，
 如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于pc端
 2.设计方法
 PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分
 优点:这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。
 缺点：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。当前，大部分门户网站、大部分企业的PC宣传站点都采用了这种布局方式。

二、流式布局
 流式布局的特点 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统 网格系统
 \1. 布局特点
 屏幕分辨率变化时，页面里元素的大小会变化而但布局不变
 \2. 设计方法
 使用%百分比定义宽度，高度大都是用px来固定住
 缺点明显：主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示

三、自适应布局
 自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。
 改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，
 页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。
 1、布局特点
 屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。
 2、设计方法
 使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。
 在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。

四、响应式布局
 \1. 布局特点
 每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变
 \2. 设计方法
 媒体查询+流式布局。
 优点：适应pc和移动端，如果足够耐心，效果完美。
 缺点：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。
 （2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。

五、弹性布局（rem/em布局）
 \1. rem/em区别：rem是相对于html元素的font-size大小而言的，而em是相对于其父元素
 \2. 使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示
 \3. 浏览器的默认字体高度一般为16px，即1em:16px，但是 1:16 的比例不方便计算，为了使单位em/rem更直观，
 CSS编写者常常将页面跟节点字体设为62.5%，比如选择用rem控制字体时，先需要设置根节点html的字体大小，
 因为浏览器默认字体大小16px*62.5%=10px。这样1rem便是10px，方便了计算。

结论
 1.如果只做pc端，那么静态布局（定宽度）是最好的选择；
 2.如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份css+一份js调节font-size搞定；
 3.如果pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。



响应式布局等于流动网格布局，而自适应布局等于使用固定分割点来进行布局。

自适应布局给了你更多设计的空间，因为你只用考虑几种不同的状态。而在响应式布局中你却得考虑上百种不同的状态。虽然绝大部分状态差异较小，但仍然也算做差异。它使得把握设计最终效果变得更难，同样让响应式布局更加的难以测试和预测。但同时说难，这也算是响应式布局美的所在

































